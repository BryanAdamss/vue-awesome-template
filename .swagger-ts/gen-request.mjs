/**
 * @author GuangHui
 * @description 扫描接口定义目录，生成openapi-typescript-fetch请求方法
 */

import fs from 'fs'
import { EOL } from 'os'
import path from 'path'

import { globbySync } from 'globby'

import { INPUT_FILES, OUTPUT_DIR } from './const.mjs'

/**
 * 提取interface path内容
 *
 * @date 2022-08-20 11:39:00
 * @param {string} cont openapi-typescript生成的文件内容
 * @return {string}  interface path内容
 * @example
 * output
 [`'/pet/{petId}': {
  get: operations['getPetById']
  post: operations['updatePetWithForm']
  delete: operations['deletePet']
}`,...]
 */
function getInterfacePathsCont(cont) {
  const startIndex = cont.indexOf('export interface paths')
  if (startIndex === -1)
    return ''

  const firstExportIndexAfterStartIndex = cont.indexOf('export', startIndex + 1)

  const endIndex = firstExportIndexAfterStartIndex === -1
    ? cont.lastIndexOf('}')
    : firstExportIndexAfterStartIndex

  return cont.slice(startIndex, endIndex)
}

/**
 * 提取pathConts
 *
 * @date 2022-08-20 11:37:33
 * @param {string} pathsCont 提取出的interface paths内容
 * @return {Array}  提取出的path字符串数组
 */
function getPathConts(pathsCont) {
  const pathContReg = /(?<PathCont>['"].*?['"].*?})/gs

  const pathConts = []
  let ret = pathContReg.exec(pathsCont)

  while (ret) {
    const { PathCont } = ret.groups

    PathCont && pathConts.push(PathCont)

    ret = pathContReg.exec(pathsCont)
  }

  pathContReg.lastIndex = 0

  return pathConts
}

/**
 * 生成FnName、Method、Path的元组
 *
 * @date 2022-08-20 11:35:00
 * @param {*} pathConts 提取出的pathConts数组
 * @return {[FnName,Method,Path]}  [FnName,Method,Path]的元组
 * @example
 * input
'/pet/{petId}': {
  get: operations['getPetById']
  post: operations['updatePetWithForm']
  delete: operations['deletePet']
}
* output
[
  ['getPetById', 'get', '/pet/{petId}'],
  ['updatePetWithForm', 'post', '/pet/{petId}'],
  ['deletePet', 'delete', '/pet/{petId}']
]
 */
function getFnNameMethodPathTuple(pathConts) {
  return pathConts.reduce((acc, pathCont) => {
    /* 匹配 */
    const PathRet = /(?<Quote>['"])(?<Path>[\/\w{}]+)\k<Quote>(?=.*?:)/.exec(pathCont)

    const { Path } = PathRet.groups

    const methodAndFnNameReg = /(?<Method>connect|delete|get|head|options|patch|post|put|trace).*?operations\[(?<Quote>['"])(?<FnName>\w+)\k<Quote>\]/g

    let methodAndFnNameRegRet = methodAndFnNameReg.exec(pathCont)

    while (methodAndFnNameRegRet) {
      const { Method, FnName } = methodAndFnNameRegRet.groups

      acc.push([FnName, Method, Path])
      methodAndFnNameRegRet = methodAndFnNameReg.exec(pathCont)
    }

    return acc
  }
  , [])
}

function genRequestFile(filePath) {
  const apiTsContent = fs.readFileSync(
    filePath,
    'utf-8',
  )

  const interfacePathCont = getInterfacePathsCont(apiTsContent)
  const pathConts = getPathConts(interfacePathCont)
  const fnNameMethodPathTuple = getFnNameMethodPathTuple(pathConts)
  const baseName = path.basename(filePath, '.ts')

  const strArr = fnNameMethodPathTuple.reduce((acc, [fnName, method, path]) => {
    return acc.concat(`export const ${fnName} = fetcher.path('${path}').method('${method}').create()${EOL}`)
  }, [])

  strArr.unshift(`import { fetcher } from \'@/services/instance/${baseName}-request-instance\'${EOL}`)

  strArr.unshift(`/**
  * This file was auto-generated by .swagger-ts/gen-request.mjs.
  * Do not make direct changes to the file.
  * Please change ${filePath}, then regenerate it.
  */${EOL}`)

  const outputFilePath = path.join(process.cwd(), OUTPUT_DIR, `${baseName}-request.ts`)

  fs.writeFileSync(
    outputFilePath,
    strArr.join(`${EOL}`),
    (err) => {
      console.log(err)
    })

  console.log(`${outputFilePath} generated.`)
}

function main() {
  const files = globbySync(
    INPUT_FILES,
    {
      ignore: ['**/node_modules/**'],
    },
  )

  for (let index = 0; index < files.length; index++) {
    const filePath = files[index]
    genRequestFile(filePath)
  }
}

main()
